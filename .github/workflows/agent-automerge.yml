name: Agent Auto Merge

on:
  workflow_run:
    workflows:
      - "Guardrails (planning-only)"
      - "Docs CI (agent review)"
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  merge_on_green:
    runs-on: ubuntu-latest

    steps:
      - name: Merge PRs labeled automerge when checks pass
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const run = context.payload.workflow_run;

            if (run.conclusion !== 'success') {
              core.info(`Workflow run concluded with ${run.conclusion}; skipping.`);
              return;
            }

            const sha = run.head_sha;
            core.info(`Evaluating PRs for head SHA: ${sha}`);

            // Find PRs associated with this commit.
            // This endpoint is supported in GitHub REST (list pull requests associated with a commit).
            const prsResp = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner,
              repo,
              commit_sha: sha,
            });

            const prs = prsResp.data
              .filter(pr => pr.state === 'open')
              .filter(pr => pr.base && pr.base.ref === 'main');

            if (prs.length === 0) {
              core.info('No open PRs against main for this SHA.');
              return;
            }

            // We consider the PR mergeable if both job check-runs succeeded.
            const requiredCheckRunNames = new Set(['guardrails', 'docs_ci']);

            const checks = await github.rest.checks.listForRef({ owner, repo, ref: sha });
            const runs = checks.data.check_runs;

            const conclusionsByName = new Map();
            for (const r of runs) {
              // Only consider completed runs.
              if (r.status !== 'completed') continue;
              conclusionsByName.set(r.name, r.conclusion);
            }

            function requiredChecksPassed() {
              for (const name of requiredCheckRunNames) {
                const conc = conclusionsByName.get(name);
                if (conc !== 'success') return false;
              }
              return true;
            }

            for (const pr of prs) {
              const labels = (pr.labels || []).map(l => l.name);
              if (!labels.includes('automerge')) {
                core.info(`PR #${pr.number} has no automerge label; skipping.`);
                continue;
              }

              // Re-fetch PR to get latest mergeability fields.
              const prFull = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });

              if (!requiredChecksPassed()) {
                core.info(`PR #${pr.number}: required checks not yet all green; skipping.`);
                continue;
              }

              // If GitHub reports conflicts, don't force.
              if (prFull.data.mergeable === false) {
                core.warning(`PR #${pr.number}: mergeable=false (conflicts). Skipping.`);
                continue;
              }

              core.info(`Merging PR #${pr.number} (squash).`);
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pr.number,
                merge_method: 'squash',
              });

              core.info(`Merged PR #${pr.number}.`);
            }
